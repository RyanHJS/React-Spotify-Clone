"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.round = exports.pick = exports.messages = exports.limit = exports.isString = exports.isRGBArray = exports.isRGB = exports.isPlainObject = exports.isNumber = exports.isHSL = exports.invariant = exports.expr = exports.constrainDegrees = exports.constrain = exports.RGBKeys = exports.HSLKeys = void 0;
exports.HSLKeys = ['h', 's', 'l'];
exports.RGBKeys = ['r', 'g', 'b'];
/**
 * Constrain value into the range
 */
function constrain(input, amount, range, sign) {
    invariant(arguments.length === 4, 'All parameters are required');
    const [min, max] = range;
    let value = expr(input + sign + amount);
    if (value < min) {
        value = min;
    }
    else if (value > max) {
        value = max;
    }
    return Math.abs(value);
}
exports.constrain = constrain;
/**
 * Constrain an angle
 */
function constrainDegrees(input, amount) {
    invariant(isNumber(input), 'input is required');
    let value = input + amount;
    if (value > 360) {
        value %= 360;
    }
    if (value < 0) {
        value += 360;
    }
    return Math.abs(value);
}
exports.constrainDegrees = constrainDegrees;
/**
 * Parse math string expressions
 */
function expr(input) {
    const chars = [...input];
    const n = [];
    const op = [];
    let parsed;
    let index = 0;
    let last = true;
    n[index] = '';
    // Parse the string
    for (const char of chars) {
        if (Number.isNaN(parseInt(char, 10)) && char !== '.' && !last) {
            op[index] = char;
            index++;
            n[index] = '';
            last = true;
        }
        else {
            n[index] += char;
            last = false;
        }
    }
    // Calculate the expression
    parsed = parseFloat(n[0]);
    for (const [o, element] of op.entries()) {
        const value = parseFloat(n[o + 1]);
        switch (element) {
            case '+':
                parsed += value;
                break;
            case '-':
                parsed -= value;
                break;
            case '*':
                parsed *= value;
                break;
            case '/':
                parsed /= value;
                break;
            default:
                break;
        }
    }
    return parsed;
}
exports.expr = expr;
function invariant(condition, message) {
    if (condition) {
        return;
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
        if (message === undefined) {
            throw new Error('invariant requires an error message argument');
        }
    }
    let error;
    if (!message) {
        throw new Error('Minified exception occurred; use the non-minified dev environment ' +
            'for the full error message and additional helpful warnings.');
    }
    else {
        error = new Error(message);
    }
    error.name = 'colorizr';
    throw error;
}
exports.invariant = invariant;
/**
 * Check if an object contains HSL values
 */
function isHSL(input) {
    if (!isPlainObject(input)) {
        return false;
    }
    const entries = Object.entries(input);
    return (!!entries.length &&
        entries.every(([key, value]) => exports.HSLKeys.includes(key) && value >= 0 && value <= (key === 'h' ? 360 : 100)));
}
exports.isHSL = isHSL;
/**
 * Check if the input is a number and not NaN
 */
function isNumber(input) {
    return typeof input === 'number' && !Number.isNaN(input);
}
exports.isNumber = isNumber;
/**
 * Check if the input is an object
 */
function isPlainObject(input) {
    if (!input) {
        return false;
    }
    const { toString } = Object.prototype;
    const prototype = Object.getPrototypeOf(input);
    return (toString.call(input) === '[object Object]' &&
        (prototype === null || prototype === Object.getPrototypeOf({})));
}
exports.isPlainObject = isPlainObject;
/**
 * Check if an object contains RGB values.
 */
function isRGB(input) {
    if (!isPlainObject(input)) {
        return false;
    }
    const entries = Object.entries(input);
    return (!!entries.length &&
        entries.every(([key, value]) => exports.RGBKeys.includes(key) && value >= 0 && value <= 255));
}
exports.isRGB = isRGB;
/**
 * Check if an array contains RGB values.
 */
function isRGBArray(input) {
    return Array.isArray(input) && input.length === 3 && input.every(d => d >= 0 && d <= 255);
}
exports.isRGBArray = isRGBArray;
/**
 * Check if the input is a string
 */
function isString(input) {
    return typeof input === 'string';
}
exports.isString = isString;
/**
 * Limit values per type.
 */
function limit(input, type) {
    invariant(isNumber(input), 'Input is not a number');
    /* istanbul ignore else */
    if (exports.RGBKeys.includes(type)) {
        return Math.max(Math.min(input, 255), 0);
    }
    if (['s', 'l'].includes(type)) {
        return Math.max(Math.min(input, 100), 0);
    }
    if (type === 'h') {
        return Math.max(Math.min(input, 360), 0);
    }
    throw new Error('Invalid type');
}
exports.limit = limit;
exports.messages = {
    amount: 'amount must be a number',
    left: 'left is required and must be a string',
    right: 'right is required and must be a string',
    input: 'input is required',
    inputString: 'input is required and must be a string',
    invalid: 'invalid input',
    options: 'invalid options',
};
/**
 * Creates an object composed of the picked source properties.
 */
function pick(input, options) {
    if (!Array.isArray(options)) {
        throw new TypeError('options must be an array');
    }
    return options
        .filter(d => typeof input[d] !== 'undefined')
        .reduce((acc, d) => {
        acc[d] = input[d];
        return acc;
    }, {});
}
exports.pick = pick;
/**
 * Round decimal numbers.
 */
function round(input, digits = 2) {
    const factor = 10 ** digits;
    return Math.round(input * factor) / factor;
}
exports.round = round;
//# sourceMappingURL=utils.js.map